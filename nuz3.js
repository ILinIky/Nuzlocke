/* ========================= App + Multiplayer (merged) ========================= */ /* ---------- Utilities ---------- */ const $ = sel => document.querySelector(sel); const $$ = sel => Array.from(document.querySelectorAll(sel)); const SPRITE = id => `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${id}.png`; const now = () => new Date().toISOString(); const uid = () => Math.random().toString(36).slice(2) + Date.now().toString(36); const toTitle = name => name ? name.charAt(0).toUpperCase() + name.slice(1) : ""; /* Race-Guard: während wir aktiv zum Server schreiben, nicht sofort vom Server zurückspiegeln */ let nzLocalHoldUntil = 0; function holdSync(ms = 1500){ nzLocalHoldUntil = Date.now() + ms; } /* ---------- Persistence ---------- */ const LS_KEY = 'nuzlocke_state_v1'; const POKEDEX_KEY = 'nuz_pokedex_v2'; const DEFAULT_ROUTES = [ 'Route 1','Route 2','Route 3','Route 4','Route 5','Route 6', 'Viridian Forest','Pewter City','Mt. Moon','Cerulean City','Route 24','Route 25' ]; const EMPTY_STATE = () => ({ user: { name: '' }, routes: DEFAULT_ROUTES.map((n, i) => ({ id: 'r'+(i+1), name:n, encounter: { status:'pending', pokemonId:null, pokemonName:'', sprite:null, nickname:'', updatedAt:null } })), box: [], // {uid,id,name,sprite,routeName,nickname,caughtAt,isInTeam:false} team: [null,null,null,null,null,null], links: { 0:null,1:null,2:null,3:null,4:null,5:null } }); let state = null; let selectedFromBoxUid = null; function save(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); } function load(){ const s = localStorage.getItem(LS_KEY); state = s ? JSON.parse(s) : EMPTY_STATE(); } /* ---------- Pokédex ---------- */ let pokedex = []; async function ensurePokedex(){ const cached = localStorage.getItem(POKEDEX_KEY); if(cached){ pokedex = JSON.parse(cached); return; } try{ const res = await fetch('https://pokeapi.co/api/v2/pokemon?limit=1025'); const data = await res.json(); pokedex = data.results.map(x => { const m = x.url.match(/pokemon\/(\d+)\/?$/); return { id: m?Number(m[1]):null, name: x.name }; }).filter(x=>x.id); localStorage.setItem(POKEDEX_KEY, JSON.stringify(pokedex)); }catch{ pokedex = [ {id:1,name:'bulbasaur'},{id:4,name:'charmander'},{id:7,name:'squirtle'}, {id:10,name:'caterpie'},{id:16,name:'pidgey'},{id:19,name:'rattata'}, {id:25,name:'pikachu'},{id:35,name:'clefairy'},{id:39,name:'jigglypuff'}, {id:52,name:'meowth'},{id:54,name:'psyduck'},{id:63,name:'abra'}, {id:66,name:'machop'},{id:74,name:'geodude'},{id:77,name:'ponyta'}, {id:81,name:'magnemite'},{id:92,name:'gastly'},{id:95,name:'onix'}, {id:98,name:'krabby'},{id:116,name:'horsea'},{id:129,name:'magikarp'}, {id:133,name:'eevee'},{id:143,name:'snorlax'},{id:147,name:'dratini'} ]; } } /* ---------- Tabs ---------- */ function setActiveTab(tab){ $$('#tabs .tab-btn').forEach(b=>b.classList.toggle('active', b.dataset.tab===tab)); $$('.panel').forEach(p=>p.classList.toggle('active', p.id === `panel-${tab}`)); } /* ---------- Routes ---------- */ let currentRouteId = null; function renderRoutes(){ const wrap = $('#routesList'); wrap.innerHTML = ''; state.routes.forEach(rt => { const div = document.createElement('div'); div.className = 'route-item' + (currentRouteId===rt.id ? ' active' : ''); const status = rt.encounter.status; const statusText = status==='pending'?'(offen)':status==='caught'?'(gefangen)':'(fehlversuch)'; div.innerHTML = `${rt.name} ${statusText}`; div.onclick = ()=>{ currentRouteId = rt.id; renderRoutes(); renderEncounter(); }; wrap.appendChild(div); }); } function renderEncounter(){ const pane = $('#encounterPane'); const rt = state.routes.find(r=>r.id===currentRouteId); if(!rt){ pane.innerHTML = '<p>Wähle links eine Route.</p>'; return; } const e = rt.encounter; const listHtml = pokedex.slice(0,1025).map(p=>`<option value="${toTitle(p.name)}">#${p.id} ${toTitle(p.name)}</option>`).join(''); const hasMon = !!e.pokemonId; pane.innerHTML = ` <div class="enc-row"> <div id="encSprite" class="enc-sprite">${hasMon?`<img src="${SPRITE(e.pokemonId)}" alt="${e.pokemonName}">`:'—'}</div> <div class="enc-form"> <label>Pokémon</label> <input id="pokeSearch" list="pokeList" placeholder="Name (z. B. Pikachu)" value="${toTitle(e.pokemonName)}" /> <datalist id="pokeList">${listHtml}</datalist> <label>Spitzname</label> <input id="nickname" placeholder="optional" value="${e.nickname||''}" /> <div class="row"> <button id="btnCaught">Gefangen</button> <button id="btnFailed" class="ghost">Fehlversuch</button> <button id="btnClear" class="ghost">Zurücksetzen</button> </div> <div class="muted">Status: ${e.status==='pending'?'Offen':e.status==='caught'?'Gefangen':'Fehlversuch'} ${e.updatedAt?`• zuletzt aktualisiert: ${new Date(e.updatedAt).toLocaleString()}`:''}</div> </div> </div> <h3>Regeln & Hinweise</h3> <ul> <li>Nur das erste Pokémon der Route zählt.</li> <li>Markiere es als Gefangen, um es in die Box zu legen.</li> <li>Du kannst einen Spitznamen vergeben.</li> <li>Ziehe das Pokémon später in einen Team-Slot.</li> </ul> `; const search = $('#pokeSearch'); const nick = $('#nickname'); const btnCaught = $('#btnCaught'); const btnFailed = $('#btnFailed'); const btnClear = $('#btnClear'); function resolvePokemon(str){ if(!str) return null; const name = str.trim().toLowerCase(); let found = pokedex.find(p=>p.name===name); if(!found) found = pokedex.find(p=>toTitle(p.name)===str.trim()); return found || null; } function updatePreview(){ const chosen = resolvePokemon(search.value); const sprite = chosen? SPRITE(chosen.id) : null; $('#encSprite').innerHTML = chosen? `<img src="${sprite}" alt="${chosen.name}">` : '—'; } search.addEventListener('input', updatePreview); btnCaught.onclick = ()=>{ const chosen = resolvePokemon(search.value); if(!chosen) { alert('Bitte ein gültiges Pokémon auswählen.'); return; } rt.encounter = { status:'caught', pokemonId: chosen.id, pokemonName: chosen.name, sprite: SPRITE(chosen.id), nickname: nick.value.trim(), updatedAt: now() }; const exists = state.box.find(m=>m.routeName===rt.name); if(!exists){ state.box.push({ uid:uid(), id:chosen.id, name:chosen.name, sprite:SPRITE(chosen.id), routeName:rt.name, nickname:nick.value.trim(), caughtAt:now(), isInTeam:false }); } save(); renderRoutes(); renderEncounter(); renderBox(); renderBoxDrawer(); renderRouteGroups(); // Server: species für "All Teams" aktualisieren if (window.NZ) window.NZ.upsertPokemon(rt.name, toTitle(chosen.name), true).catch(console.error); }; btnFailed.onclick = ()=>{ rt.encounter = { status:'failed', pokemonId:null, pokemonName:'', sprite:null, nickname:'', updatedAt: now() }; const idx = state.box.findIndex(m=>m.routeName===rt.name && !m.isInTeam); if(idx>=0){ state.box.splice(idx,1); } save(); renderRoutes(); renderEncounter(); renderBox(); renderBoxDrawer(); renderRouteGroups(); }; btnClear.onclick = ()=>{ rt.encounter = { status:'pending', pokemonId:null, pokemonName:'', sprite:null, nickname:'', updatedAt: now() }; const idx = state.box.findIndex(m=>m.routeName===rt.name && !m.isInTeam); if(idx>=0){ state.box.splice(idx,1); } save(); renderRoutes(); renderEncounter(); renderBox(); renderBoxDrawer(); renderRouteGroups(); }; updatePreview(); } /* ---------- Box Drawer ---------- */ function renderBoxDrawer(){ const grid = $('#boxDrawer'); if(!grid) return; grid.innerHTML = ''; state.box.forEach(mon =>{ const card = document.createElement('div'); card.className = 'poke-card'; card.draggable = true; card.dataset.uid = mon.uid; card.setAttribute('data-route', mon.routeName); card.innerHTML = `<div class="sprite"><img src="${mon.sprite}" alt="${mon.name}"></div> <div class="name">#${mon.id} ${toTitle(mon.name)} ${mon.nickname?`“${mon.nickname}”`:''}</div> <div class="route">${mon.routeName}</div> ${mon.isInTeam?`<div class="badge">Im Team</div>`:''} `; card.addEventListener('dragstart', e=>{ card.classList.add('dragging'); e.dataTransfer.setData('text/plain', mon.uid); e.dataTransfer.setData('text/route', mon.routeName); }); card.addEventListener('dragend', ()=>card.classList.remove('dragging')); card.addEventListener('click', ()=>{ selectedFromBoxUid = mon.uid; renderTeam(); const el = document.querySelector(`#boxDrawer [data-uid="${mon.uid}"]`); if(el){ el.classList.add('selected'); setTimeout(()=>el.classList.remove('selected'), 1000); } $('#pickHint').style.display = 'block'; }); grid.appendChild(card); }); } /* ---------- Box Tab ---------- */ function renderBox(){ const grid = $('#boxGrid'); if(!grid) return; grid.innerHTML = ''; state.box.forEach(mon =>{ const card = document.createElement('div'); card.className = 'poke-card'; card.draggable = true; card.dataset.uid = mon.uid; card.setAttribute('data-route', mon.routeName); card.innerHTML = `<div class="sprite"><img src="${mon.sprite}" alt="${mon.name}"></div> <div class="name">#${mon.id} ${toTitle(mon.name)} ${mon.nickname?`“${mon.nickname}”`:''}</div> <div class="route">${mon.routeName}</div> <button class="ghost small" data-remove>Entfernen</button> ${mon.isInTeam?`<div class="badge">Im Team</div>`:''} `; card.addEventListener('dragstart', e=>{ card.classList.add('dragging'); e.dataTransfer.setData('text/plain', mon.uid); e.dataTransfer.setData('text/route', mon.routeName); }); card.addEventListener('dragend', ()=>card.classList.remove('dragging')); card.querySelector('[data-remove]').onclick = (ev)=>{ ev.stopPropagation(); if(mon.isInTeam){ alert('Dieses Pokémon ist im Team.\nEntferne es zuerst aus dem Team.'); return; } const i = state.box.findIndex(x=>x.uid===mon.uid); if(i>=0) state.box.splice(i,1); save(); renderBox(); renderTeam(); renderBoxDrawer(); renderRouteGroups(); }; card.addEventListener('click', (ev)=>{ if(ev.target.closest('[data-remove]')) return; selectedFromBoxUid = mon.uid; setActiveTab('team'); renderTeam(); renderBoxDrawer(); renderRouteGroups(); const el = document.querySelector(`#boxDrawer [data-uid="${mon.uid}"]`); if(el){ el.classList.add('selected'); el.scrollIntoView({behavior:'smooth', block:'center'}); setTimeout(()=>el.classList.remove('selected'), 1000); } $('#pickHint').style.display = 'block'; }); grid.appendChild(card); }); } /* ---------- Team ---------- */ function renderTeam(){ const wrap = $('#teamWrap'); if (!wrap) return; wrap.innerHTML = ''; for(let i=0;i<6;i++){ const uidRef = state.team[i]; const mon = uidRef ? state.box.find(m=>m.uid===uidRef) : null; const slot = document.createElement('div'); slot.className = 'slot'; slot.dataset.index = i; slot.innerHTML = mon ? `<div class="sprite"><img src="${mon.sprite}" alt="${mon.name}"></div> <div class="name">#${mon.id} ${toTitle(mon.name)} ${mon.nickname?`“${mon.nickname}”`:''}</div> <button class="ghost small" data-remove>Aus Team</button>` : ` <div class="empty">(leer)</div> <div class="hint">Ziehe ein Pokémon hierher oder klicke zur Auswahl</div>`; // Drag & Drop slot.addEventListener('dragover', e=>{ e.preventDefault(); slot.classList.add('over'); }); slot.addEventListener('dragleave', ()=>slot.classList.remove('over')); slot.addEventListener('drop', async e=>{ e.preventDefault(); slot.classList.remove('over'); const uid = e.dataTransfer.getData('text/plain'); const mon = state.box.find(m=>m.uid===uid); if(!mon) return; const targetSlot = i + 1; const route = mon.routeName || e.dataTransfer.getData('text/route') || ''; // Vorheriger Inhalt in DIESEM Slot const prevUid = state.team[i]; const prevMon = prevUid ? state.box.find(m=>m.uid===prevUid) : null; const prevRoute = prevMon?.routeName || null; // Lokal updaten const already = state.team.findIndex(u=>u===uid); if(already>=0){ const back = state.team[i]; state.team[already] = back || null; } if(prevMon) prevMon.isInTeam = false; state.team[i] = uid; mon.isInTeam = true; selectedFromBoxUid = null; save(); renderTeam(); renderBox(); renderBoxDrawer(); renderRouteGroups(); $('#pickHint').style.display = 'none'; // Server: idempotent & atomisch // --- Server: idempotent & atomisch try { if (window.NZ && route) { await window.NZ.ensureJoined(); holdSync(1500); // Route→Slot setzen (robust) await window.NZ.setRouteSlot(route, targetSlot); // species/caught updaten await window.NZ.upsertPokemon(route, toTitle(mon.name), true); await window.NZ.syncNow?.(); } } catch (err) { console.error('[NZ] drop sync failed:', err); } }); // Click-to-place slot.addEventListener('click', async ()=>{ if(!selectedFromBoxUid) return; const pick = state.box.find(m=>m.uid===selectedFromBoxUid); if(!pick) return; const targetSlot = i + 1; const route = pick.routeName || ''; // Vorheriger Inhalt const prevUid = state.team[i]; const prevMon = prevUid ? state.box.find(m=>m.uid===prevUid) : null; const prevRoute = prevMon?.routeName || null; // Lokal const already = state.team.findIndex(u=>u===pick.uid); if(already>=0){ const back = state.team[i]; state.team[already] = back || null; } if(prevMon) prevMon.isInTeam = false; state.team[i] = pick.uid; pick.isInTeam = true; selectedFromBoxUid = null; save(); renderTeam(); renderBox(); renderBoxDrawer(); renderRouteGroups(); $('#pickHint').style.display = 'none'; // Server try { if (window.NZ && route) { await window.NZ.ensureJoined(); holdSync(1500); await window.NZ.setRouteSlot(route, targetSlot); await window.NZ.upsertPokemon(route, toTitle(pick.name), true); await window.NZ.syncNow?.(); } } catch (err) { console.error('[NZ] click sync failed:', err); } }); // Remove-Button if (mon){ slot.querySelector('[data-remove]').onclick = async ()=>{ const route = mon.routeName; state.team[i] = null; mon.isInTeam = false; save(); renderTeam(); renderBox(); renderBoxDrawer(); renderRouteGroups(); try { if (window.NZ && route) { await window.NZ.ensureJoined(); holdSync(1000); await window.NZ.clearRouteSlot(route); await window.NZ.syncNow?.(); } } catch (err) { console.error('[NZ] remove sync failed:', err); } }; } wrap.appendChild(slot); } } function renderRouteGroups(){ const holder = $('#routeGroups'); if(!holder) return; holder.innerHTML = ''; const groups = {}; state.team.forEach(uid=>{ if(!uid) return; const mon = state.box.find(m=>m.uid===uid); if(!mon) return; groups[mon.routeName] = groups[mon.routeName] || []; groups[mon.routeName].push(mon); }); const names = Object.keys(groups); if(names.length===0){ holder.innerHTML = '<div class="muted">Noch keine Team-Pokémon – keine Route-Verknüpfungen.</div>'; return; } names.sort().forEach(rn=>{ const mons = groups[rn]; const div = document.createElement('div'); div.className = 'row'; const list = mons.map(m=>`#${m.id} ${toTitle(m.name)}${m.nickname?` “${m.nickname}”`:''}`).join(', '); div.innerHTML = `${rn}: ${list}`; holder.appendChild(div); }); } /* ---------- Simple local Lobby badge (unabhängig vom Multiplayer-UI) ---------- */ function renderLocalLobbyBadge(){ $('#playerNameBadge').textContent = state.user?.name || '–'; const list = $('#playersList'); if(!list) return; list.innerHTML = ''; const me = document.createElement('div'); me.className = 'player'; me.innerHTML = `${state.user?.name || 'Unbekannt'}<span class="muted">(Host)</span>`; list.appendChild(me); } /* ---------- Import / Export ---------- */ function exportData(){ const blob = new Blob([JSON.stringify(state,null,2)], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download = `nuzlocke_${(state.user.name||'trainer').toLowerCase()}_${Date.now()}.json`; a.click(); URL.revokeObjectURL(url); } async function importData(file){ const text = await file.text(); try{ const obj = JSON.parse(text); if(!obj || !obj.user || !obj.routes || !obj.box || !obj.team) throw new Error('Ungültiges Format'); state = obj; save(); renderRoutes(); renderEncounter(); renderBox(); renderTeam(); renderBoxDrawer(); renderRouteGroups(); renderLocalLobbyBadge(); // Nach Import: Box → Server spiegeln if (window.NZ) { try { await window.NZ.ensureJoined(); const seen = new Set(); const tasks = []; for (const m of state.box) { if (m.routeName && !seen.has(m.routeName)) { seen.add(m.routeName); tasks.push(window.NZ.upsertPokemon(m.routeName, toTitle(m.name), true)); } } if (tasks.length) await Promise.all(tasks); await window.NZ.syncNow?.(); } catch(e) { console.warn("[NZ] bulk sync after import failed:", e); } } alert('Import erfolgreich.'); }catch(e){ alert('Fehler beim Import: '+ e.message); } } /* ---------- Login ---------- */ function ensureLogin(){ const overlay = $('#loginOverlay'); const shouldShow = !state.user || !state.user.name; if(overlay){ overlay.hidden = !shouldShow; overlay.style.display = shouldShow ? 'grid' : 'none'; overlay.setAttribute('aria-hidden', String(!shouldShow)); } $('#playerNameBadge').textContent = state.user?.name || '–'; } /* ---------- Boot ---------- */ function boot(){ load(); $$('#tabs .tab-btn').forEach(btn=> btn.addEventListener('click',()=> setActiveTab(btn.dataset.tab)) ); $('#addRouteBtn')?.addEventListener('click', ()=>{ const name = $('#addRouteName').value.trim(); if(!name) return; state.routes.push({ id: 'r'+uid(), name, encounter:{ status:'pending', pokemonId:null, pokemonName:'', sprite:null, nickname:'', updatedAt:null } }); save(); $('#addRouteName').value=''; renderRoutes(); }); $('#exportBtn')?.addEventListener('click', exportData); $('#importFile')?.addEventListener('change', e=>{ const f=e.target.files[0]; if(f) importData(f); e.target.value=''; }); $('#startBtn')?.addEventListener('click', ()=>{ const name = $('#trainerName').value.trim(); if(!name) return alert('Bitte gib einen Namen ein.'); state.user.name = name; save(); ensureLogin(); }); renderRoutes(); renderEncounter(); renderBox(); renderTeam(); renderBoxDrawer(); renderRouteGroups(); renderLocalLobbyBadge(); ensureLogin(); ensurePokedex().then(()=>{ renderEncounter(); save(); }).catch(()=>{}); } boot(); /* ========================================================== Multiplayer (nur #nz-lobby und #nz-allteams; keine Doppel-UI) ========================================================== */ const NZ_API = "/api/nuzlocke"; const NZ_HEARTBEAT_MS = 15000; const NZ_POLL_MS = 4000; let nzPlayerId = localStorage.getItem("playerId") || ""; let nzPlayerName = localStorage.getItem("playerName") || ""; let nzLobbyCode = (new URL(location.href)).searchParams.get("code") || localStorage.getItem("lobbyCode") || ""; const elLobbyPane = $("#nz-lobby"); const elAllTeams = $("#nz-allteams"); // Cache: letzter bekannter Server-Stand route -> slot let nzLastRouteSlots = new Map(); const esc = s => String(s ?? "").replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",""":"&quot;","'":"&#39;" }[c])); // --- API helpers --- async function nzApi(action, payload = {}) { const r = await fetch(NZ_API, { method: "POST", headers: { "content-type":"application/json" }, body: JSON.stringify({ action, ...payload }), cache: "no-store" }); const t = await r.text(); let j; try { j = JSON.parse(t) } catch { j = { error: t } } if (!r.ok || j.error) throw new Error(j.error || `HTTP ${r.status}`); return j; } async function nzListState(code) { const r = await fetch(NZ_API, { method: "POST", headers: { "content-type":"application/json" }, body: JSON.stringify({ action:"list", code: (code||"").toUpperCase() }), cache: "no-store" }); if (r.ok) return r.json(); const t = await r.text(); throw new Error(`HTTP ${r.status} ${t}`); } // --- Lobby render --- function nzRenderLobby(st){ if (!elLobbyPane) return; const online = (st.players||[]).filter(p=>p.online).length; elLobbyPane.innerHTML = `<div class="row"> <div>Lobby-Code: <code id="nzCode">${esc(nzLobbyCode||st.code||"")}</code></div> <div class="row"> <label>Name:</label> <input id="nzName" placeholder="Dein Name" value="${esc(nzPlayerName||state.user?.name||"")}" /> <button id="nzCreate">Erstellen</button> <button id="nzJoin">${nzPlayerId ? "Verbinden" : "Beitreten"}</button> </div> <div class="muted">Link: <code>${esc(location.origin+location.pathname)}?code=${esc(nzLobbyCode||st.code||"")}</code></div> </div> <div class="sep"></div> <div class="muted">Spieler in Lobby: ${(st.players||[]).length} (online: ${online})</div> <div class="players">${(st.players||[]).map(p=>` <div class="player ${p.id===nzPlayerId?'me':''}"> <div class="name">${esc(p.name)}</div> <div class="dot ${p.online?"ok":"muted"}">${p.online?"online":"offline"}</div> </div> `).join("")}</div> `; elLobbyPane.querySelector("#nzCreate").onclick = async ()=>{ const nm = elLobbyPane.querySelector("#nzName").value.trim() || "Spieler"; nzPlayerName = nm; localStorage.setItem("playerName", nm); const j = await nzApi("joinLobby", { name:nm, code:"" }); nzPlayerId = j.player.id; nzLobbyCode = j.code; localStorage.setItem("playerId", nzPlayerId); localStorage.setItem("lobbyCode", nzLobbyCode); history.replaceState(null,"",`?code=${nzLobbyCode}`); await nzSync(); }; elLobbyPane.querySelector("#nzJoin").onclick = async ()=>{ const nm = elLobbyPane.querySelector("#nzName").value.trim() || "Spieler"; nzPlayerName = nm; localStorage.setItem("playerName", nm); const cd = (elLobbyPane.querySelector("#nzCode").textContent.trim() || "").toUpperCase(); if (!cd) return alert("Bitte Lobby-Code eingeben"); nzLobbyCode = cd; localStorage.setItem("lobbyCode", nzLobbyCode); if (nzPlayerId) { await nzApi("rejoinLobby", { playerId: nzPlayerId, name: nzPlayerName, code: nzLobbyCode }); } else { const j = await nzApi("joinLobby", { name: nzPlayerName, code: nzLobbyCode }); nzPlayerId = j.player.id; localStorage.setItem("playerId", nzPlayerId); } history.replaceState(null,"",`?code=${nzLobbyCode}`); await nzSync(); }; } // --- All Teams render (Sprites wie in der Box) --- function nzRenderAllTeams(st){ if (!elAllTeams) return; // route -> slot const byRoute = new Map((st.routeSlots || []).map(r => [r.route, r.slot])); const routeOf = s => { for (const [rt, sl] of byRoute.entries()) if (sl === s) return rt; return null; }; const spriteFor = (species) => { if (!species || !Array.isArray(pokedex) || pokedex.length === 0) return null; const p = pokedex.find(x => x.name === String(species).toLowerCase()); return p ? SPRITE(p.id) : null; }; const players = st.players || []; const htmlPlayers = players.map(p => { const box = (st.boxes || {})[p.id] || {}; const cells = [1,2,3,4,5,6].map(s => { const rt = routeOf(s); const mon = rt ? box[rt] : null; if (!mon) { return `<div class="slot"><div class="idx">#${s}</div><div class="empty">—</div></div>`; } const sprite = spriteFor(mon.species); if (sprite) { return `<div class="slot"><div class="idx">#${s}</div><div class="sprite"><img src="${sprite}" alt="${toTitle(mon.species)}" /></div><div class="lbl">${toTitle(mon.species)}</div><div class="muted">${rt}</div></div>`; } return `<div class="slot"><div class="idx">#${s}</div><div class="lbl">${rt}</div><div class="muted">${toTitle(mon.species)}${mon.caught ? "" : " (nicht gefangen)"}</div></div>`; }).join(""); return `<div class="player-row"><div class="player-name">Team: ${esc(p.name)}${p.online ? " (online)" : ""}</div><div class="team-row">${cells}</div></div>`; }).join(""); elAllTeams.innerHTML = `<div class="teams">${htmlPlayers || "noch keine Spieler"}</div> `; } // --- Global → Local spiegeln --- function nzApplyGlobalToLocal(st){ if (Date.now() < nzLocalHoldUntil) return; // Race-Guard aktiv → nicht überschreiben if (!state || !Array.isArray(state.team) || !Array.isArray(state.box)) return; const r2s = new Map((st.routeSlots||[]).map(x => [x.route, x.slot])); const uidByRoute = new Map(state.box.map(m => [m.routeName, m.uid])); const newTeam = [null,null,null,null,null,null]; for (const [route, slot] of r2s.entries()) { if (slot >= 1 && slot <= 6) newTeam[slot-1] = uidByRoute.get(route) || null; } state.box.forEach(m => { m.isInTeam = false; }); newTeam.forEach(uid => { const mon = state.box.find(m => m.uid === uid); if (mon) mon.isInTeam = true; }); const changed = newTeam.some((v, i) => v !== state.team[i]); if (changed) { state.team = newTeam; try { save(); renderTeam(); renderRouteGroups(); renderBox(); renderBoxDrawer(); } catch(_) {} } } // --- Heartbeat & Sync --- async function nzHeartbeat(){ if (nzPlayerId && nzLobbyCode) { try { await nzApi("heartbeat", { playerId: nzPlayerId, code: nzLobbyCode }); } catch{} } } async function nzSync(){ if (!nzLobbyCode) { nzRenderLobby({ code:"", players:[] }); return; } try { const st = await nzListState(nzLobbyCode); // Cache: letzter Stand route->slot (für Idempotenzcheck) nzLastRouteSlots = new Map((st.routeSlots || []).map(x => [x.route, x.slot])); nzRenderLobby(st); nzRenderAllTeams(st); nzApplyGlobalToLocal(st); } catch(e) { console.error("[NZ] sync failed:", e); } } setInterval(nzHeartbeat, NZ_HEARTBEAT_MS); setInterval(nzSync, NZ_POLL_MS); // --- Auto-Join bei ?code= --- (async()=>{ const urlCode = (new URL(location.href)).searchParams.get("code"); if (urlCode) { nzLobbyCode = urlCode.toUpperCase(); localStorage.setItem("lobbyCode", nzLobbyCode); } if (nzLobbyCode && !nzPlayerId) { const nm = (state?.user?.name || nzPlayerName || prompt("Dein Name?") || "Spieler").trim(); nzPlayerName = nm; localStorage.setItem("playerName", nm); const j = await nzApi("joinLobby", { name:nm, code:nzLobbyCode }); nzPlayerId = j.player.id; localStorage.setItem("playerId", nzPlayerId); } await nzSync(); })(); // --- Öffentliche Hooks --- window.NZ = { async ensureJoined(){ if (!nzLobbyCode) { const urlCode = (new URL(location.href)).searchParams.get("code"); if (urlCode) { nzLobbyCode = urlCode.toUpperCase(); localStorage.setItem("lobbyCode", nzLobbyCode); } } if (!nzPlayerId) { const nm = (state?.user?.name || nzPlayerName || prompt("Dein Name?") || "Spieler").trim(); nzPlayerName = nm; localStorage.setItem("playerName", nm); const j = await nzApi("joinLobby", { name: nm, code: nzLobbyCode || "" }); nzPlayerId = j.player.id; nzLobbyCode = j.code || nzLobbyCode || ""; localStorage.setItem("playerId", nzPlayerId); if (nzLobbyCode) { localStorage.setItem("lobbyCode", nzLobbyCode); history.replaceState(null, '', `?code=${nzLobbyCode}`); } return; } if (nzLobbyCode) { try { await nzApi("rejoinLobby", { playerId: nzPlayerId, name: (nzPlayerName || state?.user?.name || "Spieler"), code: nzLobbyCode }); } catch(_) {} } }, async upsertPokemon(route, species, caught=true){ await this.ensureJoined(); await nzApi('upsertPokemon', { code: nzLobbyCode, playerId: nzPlayerId, route, species, caught }); }, async assignGlobalSlot(route, slot){ await this.ensureJoined(); await nzApi('assignRouteSlot', { code: nzLobbyCode, playerId: nzPlayerId, route, slot }); }, // ❌ ALT: clearRouteSlot(...) hatte Fallback mit slot:null/0 // ✅ NEU: async clearRouteSlot(route){ await this.ensureJoined(); // Nur die dedizierte Action versuchen; wenn es sie nicht gibt, lassen wir es bleiben. try { await nzApi('clearRouteSlot', { code: nzLobbyCode, playerId: nzPlayerId, route }); } catch (e) { // Wenn dein Backend die Action nicht kennt oder sie optional ist, ignorieren wir das. // Wichtig: KEIN assignRouteSlot mit null/0 mehr! if (!/unknown|unsupported|not found/i.test(String(e.message || ""))) { throw e; } } }, // Idempotent: setzt Route → Slot, räumt vorher den Ziel-Slot, und umgeht "duplicate key" async setRouteSlot(route, targetSlot){ await this.ensureJoined(); if (!(targetSlot >= 1 && targetSlot <= 6)) throw new Error("slot must be 1..6"); // 1) Falls Route schon im Zielslot: fertig if (nzLastRouteSlots.get(route) === targetSlot) return; // 2) Wer liegt laut letztem Serverstand im Zielslot? (kann leer sein) let routeAtTarget = null; for (const [rt, sl] of nzLastRouteSlots.entries()){ if (sl === targetSlot) { routeAtTarget = rt; break; } } // Zielslot freiräumen (best effort) if (routeAtTarget && routeAtTarget !== route) { try { await this.clearRouteSlot(routeAtTarget); } catch (_) {} } // 3) Setzen – robust gegen "duplicate key" try { await nzApi('assignRouteSlot', { code: nzLobbyCode, playerId: nzPlayerId, route, slot: targetSlot }); } catch (e1) { const msg = String(e1.message || ""); if (/duplicate|unique|exists/i.test(msg)) { // Versuch per UPDATE/UPSERT try { await nzApi('updateRouteSlot', { code: nzLobbyCode, playerId: nzPlayerId, route, slot: targetSlot }); } catch (e2) { try { await nzApi('upsertRouteSlot', { code: nzLobbyCode, playerId: nzPlayerId, route, slot: targetSlot }); } catch (e3) { // letzter Versuch: aktuelle Route löschen → dann normal setzen try { await this.clearRouteSlot(route); await nzApi('assignRouteSlot', { code: nzLobbyCode, playerId: nzPlayerId, route, slot: targetSlot }); } catch (e4) { throw e4; } } } } else { throw e1; } } // 4) lokalen Cache aktualisieren nzLastRouteSlots.set(route, targetSlot); }, async syncNow(){ await nzSync(); }, get me(){ return { playerId: nzPlayerId, playerName: nzPlayerName, lobbyCode: nzLobbyCode } } }; /* --- Fallback: dragstart stellt sicher, dass die Route immer mitgegeben wird --- */ document.addEventListener("dragstart", e => { const card = e.target?.closest?.("[data-uid]"); if (!card || !state?.box) return; const u = card.getAttribute("data-uid"); const mon = state.box.find(m => m.uid === u); if (!mon) return; try { card.setAttribute("data-route", mon.routeName); e.dataTransfer?.setData?.("text/route", mon.routeName); } catch {} }, true); 

/* ======================== NZ Multiplayer Robust Patch (appended) ========================
This patch hardens NZ.setRouteSlot / clearRouteSlot against:
- 500 duplicate key on route_slots_pkey → treated as success (idempotent)
- 400 Bad Request due to missing/expired context → rejoin + one retry
- Overposting: per-route inflight guard + cache no-op when unchanged
- Immediate sync after changes

It overrides window.NZ methods while preserving your UI.
======================================================================================= */
(function(){
  const NZ_API = "/api/nuzlocke"; // keep aligned with your dev server
  const inflightByRoute = new Map();

  function getCtx(){
    const code = localStorage.getItem("lobbyCode") || (window.NZ?.me?.lobbyCode) || "";
    const playerId = localStorage.getItem("playerId") || (window.NZ?.me?.playerId) || "";
    return { code, playerId };
  }
  async function api(action, payload={}){
    const r = await fetch(NZ_API, {
      method: "POST",
      headers: { "content-type":"application/json" },
      body: JSON.stringify({ action, ...payload }),
      cache: "no-store"
    });
    const t = await r.text();
    let j; try { j = JSON.parse(t) } catch { j = { error: t } }
    if (!r.ok || j.error) throw new Error(j.error || `HTTP ${r.status}`);
    return j;
  }
  function isDup(msg){ return /duplicate key|unique|exists|route_slots.*pkey/i.test(String(msg||"")); }

  const orig = window.NZ || {};

  window.NZ = {
    ...orig,

    async setRouteSlot(route, slot){
      await (orig.ensureJoined?.());
      slot = Math.max(1, Math.min(6, Number(slot)||0));
      if (!route || !slot) return;

      if (typeof nzLastRouteSlots !== 'undefined' && nzLastRouteSlots.get(route) === slot) return;

      if (inflightByRoute.has(route)) {
        try { await inflightByRoute.get(route); } catch {}
        if (typeof nzLastRouteSlots !== 'undefined' && nzLastRouteSlots.get(route) === slot) return;
      }

      const p = (async () => {
        const { code, playerId } = getCtx();
        try {
          await api('assignRouteSlot', { code, playerId, route, slot });
          if (typeof nzLastRouteSlots !== 'undefined') nzLastRouteSlots.set(route, slot);
        } catch (e1) {
          const m = String(e1.message || e1);
          if (isDup(m)) {
            if (typeof nzLastRouteSlots !== 'undefined') nzLastRouteSlots.set(route, slot);
          } else if (/HTTP 400/i.test(m)) {
            try {
              await (orig.ensureJoined?.());
              const ctx = getCtx();
              await api('assignRouteSlot', { ...ctx, route, slot });
              if (typeof nzLastRouteSlots !== 'undefined') nzLastRouteSlots.set(route, slot);
            } catch(e2){
              console.error("[NZ patch] retry failed:", e2);
              throw e2;
            }
          } else {
            throw e1;
          }
        } finally {
          try { await (orig.syncNow?.()); } catch {}
        }
      })();
      inflightByRoute.set(route, p);
      try { await p; } finally { inflightByRoute.delete(route); }
    },

    async clearRouteSlot(route){
      await (orig.ensureJoined?.());
      if (!route) return;

      if (inflightByRoute.has(route)) {
        try { await inflightByRoute.get(route); } catch {}
      }

      const p = (async () => {
        const { code, playerId } = getCtx();
        try {
          await api('clearRouteSlot', { code, playerId, route });
        } catch (e) {
          try {
            await api('assignRouteSlot', { code, playerId, route, slot: 0 });
          } catch(e2){
            console.error("[NZ patch] clear fallback failed:", e, e2);
            throw e2;
          }
        } finally {
          try { if (typeof nzLastRouteSlots !== 'undefined') nzLastRouteSlots.delete(route); } catch{}
          try { await (orig.syncNow?.()); } catch {}
        }
      })();
      inflightByRoute.set(route, p);
      try { await p; } finally { inflightByRoute.delete(route); }
    }
  };
})();